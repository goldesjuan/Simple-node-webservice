// Generated by CoffeeScript 1.9.2

/*
 * Facade class for sms
 */

(function() {
  var Sms, Twilio, _, async, constants, crypto, express, moment, util,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  express = require('express');

  util = require('util');

  async = require('async');

  crypto = require('crypto');

  moment = require('moment');

  _ = require('lodash');

  constants = require('../configuration/configuration');

  Twilio = require('twilio');

  moment().format();

  Sms = (function() {
    function Sms(database) {
      this.postSms = bind(this.postSms, this);
      this.twilio = new Twilio(constants.local.TWILIO_ACCOUNTSID, constants.local.TWILIO_AUTHTOKEN);
      this.database = database;
    }

    Sms.prototype.postSms = function(req, res) {
      var hash, idempotenceValidation, insertToDatabse, postToTwilio;
      return async.waterfall([
        hash = (function(_this) {
          return function(callback) {
            var error, hasher, payload;
            try {
              hasher = crypto.createHash('sha256');
            } catch (_error) {
              error = _error;
              callback("Could not create hasher " + (util.inspect(error)));
            }
            payload = req.body;
            try {
              hasher.update(JSON.stringify(payload));
            } catch (_error) {
              error = _error;
              callback("Could not create hash " + (util.inspect(error)));
            }
            hash = hasher.digest('hex');
            return callback(null, hash);
          };
        })(this), idempotenceValidation = (function(_this) {
          return function(hash, callback) {
            return _this.database.getSms(hash, function(error, result) {
              var alreadySent, now, threshold;
              if (error != null) {
                return callback(error);
              }
              if (result != null) {
                now = moment();
                threshold = moment().subtract(constants.local.NOTIFICATIONS_DUPLICATES_THRESHOLD_SEC, 's');
                alreadySent = false;
                _.forEach(result, function(sms) {
                  if (moment(sms.timestamp).isBetween(threshold, now)) {
                    return alreadySent = true;
                  }
                });
                if (alreadySent) {
                  console.log("sms " + hash + " has already been sent within the last five minutes");
                  return callback(null, true, hash);
                }
              }
              return callback(null, false, hash);
            });
          };
        })(this), postToTwilio = (function(_this) {
          return function(alreadySent, hash, callback) {
            if (alreadySent) {
              return callback(null, true, hash);
            } else {
              return _this.twilio.messages.create(req.body, function(error, result) {
                if (error != null) {
                  console.log("Error sending twilio sms to " + req.body.to + " : " + (util.inspect(error)));
                  return callback(error);
                } else {
                  return callback(null, false, hash);
                }
              });
            }
          };
        })(this), insertToDatabse = (function(_this) {
          return function(alreadySent, hash, callback) {
            var sms, timestamp;
            if (alreadySent) {
              return callback(null);
            } else {
              timestamp = moment.utc().format();
              sms = {
                'hash': hash,
                'timestamp': timestamp
              };
              return _this.database.insertSms(sms, function(error, result) {
                if (error != null) {
                  console.log("Error inserting sms " + hash + " to database : " + (util.inspect(error)));
                  return callback(error);
                } else {
                  return callback(null);
                }
              });
            }
          };
        })(this)
      ], function(error, result) {
        if (error != null) {
          return res.status(500).send({
            error: "An error occured while attempting to send the sms : " + (util.inspect(error))
          });
        } else {
          return res.status(200).send({
            status: 200
          });
        }
      });
    };

    return Sms;

  })();

  module.exports = Sms;

}).call(this);
